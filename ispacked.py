from codecs import ignore_errors
import pefile
import math
import os
import sys

def calculate_entropy(data):
    if not data:
        return 0
    entropy = 0
    # 在 Python 3 中直接迭代 bytes 对象得到每个字节的整数值
    for x in range(256):
        # 使用 bytes 对象的 count 方法，参数是整数 x
        p_x = float(data.count(x)) / len(data)
        if p_x > 0:
            entropy += -p_x * math.log(p_x, 2)
    return entropy

def is_pe_packed(pe_path):
    try:
        pe = pefile.PE(pe_path)
        total_compressed, total_pe_data = 0, 0

        for section in pe.sections:
            size_of_data = section.SizeOfRawData
            total_pe_data += size_of_data

            entropy = calculate_entropy(section.get_data())
            if entropy > 6.75:
                # 在 Python 3 中正确解码节名称
                section_name = section.Name.decode('utf-8', errors='ignore').rstrip('\x00')
                #print(f"High entropy section found: {section_name} with entropy {entropy}")
                total_compressed += size_of_data

        if total_pe_data > 0 and (float(total_compressed) / total_pe_data) > 0.2:
            #print("Overall entropy of this PE file is high, indicating it may be packed.")
            return True
        else:
            #print("This PE file does not seem to be packed.")
            return False
    except pefile.PEFormatError as e:
        print("PEFormatError:", e)
        return False

# 示例用法
if __name__ == "__main__":
    pe_path = sys.argv[1]
    if is_pe_packed(pe_path):
        print(f"{pe_path} appears to be packed.")
    else:
        print(f"{pe_path} does not appear to be packed.")

