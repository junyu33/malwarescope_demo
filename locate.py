import angr
import angrutils
import itertools
import sys
import pdb
import copy
import re, ast
from functools import reduce



def flatten_list_and_uniq(nested_list):
    flat_list = []
    for element in nested_list:
        if isinstance(element, list):
            # If element is a list, extend flat_list with the flattened element
            flat_list.extend(flatten_list_and_uniq(element))
        else:
            # If element is not a list, append it to flat_list
            flat_list.append(element)

    new_list = []
    for i in flat_list:
        duplicate = 0
        for j in new_list:
            if i.addr == j.addr:
                duplicate = 1

        if duplicate == 0:
            new_list.append(i)
            
    return new_list

def get_min_depth(func, trace):
    if func.name == 'start' or func.name == '_start':
        return 1
    else:
        min_depth = 1000000
        for caller in cfg.kb.functions.callgraph.predecessors(func.addr):
            if caller in cfg.kb.functions and cfg.kb.functions[caller] not in trace:
                trace.append(cfg.kb.functions[caller])
                min_depth = min(min_depth, get_min_depth(cfg.kb.functions[caller], trace) + 1)
                trace.remove(cfg.kb.functions[caller])
        return min_depth

def get_intersection(list1, list2):
    intersection = []
    for i in list1:
        for j in list2:
            if i.addr == j.addr:
                intersection.append(i)
    return intersection

def is_same_in_content(list1, list2):
    for i in list1:
        flag_inner = 0
        for j in list2:
            if i.addr == j.addr:
                flag_inner = 1
                break
        if flag_inner == 0:
            return False
    return True

def get_LCA(func1, func2):
    ancestor_list1 = ancestor(func1)
    ancestor_list2 = ancestor(func2)

    for ans in ancestor_list1:
        if ans.addr == func2.addr:
            return func2
    for ans in ancestor_list2:
        if ans.addr == func1.addr:
            return func1

    while get_intersection(ancestor_list1, ancestor_list2) == []:
        new_list1 = copy.deepcopy(ancestor_list1)
        new_list2 = copy.deepcopy(ancestor_list2)

        for ans in ancestor_list1:
            new_list1.extend(ancestor(ans))

        for ans in ancestor_list2:
            new_list2.extend(ancestor(ans))

        if new_list1 == ancestor_list1 and new_list2 == ancestor_list2:
            return None

        ancestor_list1 = flatten_list_and_uniq(new_list1)
        ancestor_list2 = flatten_list_and_uniq(new_list2)
        #print(ancestor_list1)
        #print(ancestor_list2)

    intersection = get_intersection(ancestor_list1, ancestor_list2)

    maxdepth = 0
    result = None
    for i in intersection:
        if get_min_depth(i, [func1, func2]) > maxdepth:
            maxdepth = get_min_depth(i, [func1, func2])
            result = i

    return result

def get_multiple_intersection(lists):
    if len(lists) == 0:
        return []
    intersection = lists[0]
    for i in range(1, len(lists)):
        intersection = get_intersection(intersection, lists[i])
    return intersection

def get_multiple_LCA(funcs):
    #print('debug: ', funcs)
    if len(funcs) == 1:
        return funcs[0]

    ancestor_lists = []
    for func in funcs: 
        myself = [func]
        myself.extend(ancestor(func))
        ancestor_lists.append(myself)

    while get_multiple_intersection(ancestor_lists) == []:
        new_lists = []
        flag = 0
        for ancestor_list in ancestor_lists:
            new_list = copy.deepcopy(ancestor_list)
            for ans in ancestor_list:
                new_list.extend(ancestor(ans))

            if not is_same_in_content(new_list, ancestor_list):
                flag = 1

            new_lists.append(flatten_list_and_uniq(new_list))
        
        if flag == 0:
            return None
        ancestor_lists = new_lists

    intersection = get_multiple_intersection(ancestor_lists)

    maxdepth = 0
    result = None
    #print('possible lca: ', intersection)
    for i in intersection:
        if get_min_depth(i, funcs) > maxdepth:
            maxdepth = get_min_depth(i, funcs)
            result = i

    return result

def get_subfunc_from_LCA(LCA, func):
    if func.addr == LCA.addr:
        return func

    ancestor_list1 = ancestor(func)
    for ans in ancestor_list1:
        if ans.addr == LCA.addr:
            return func

    while True:
        new_list = copy.deepcopy(ancestor_list1)
        for ans in ancestor_list1:
            new_list.extend(ancestor(ans))
        ancestor_list1 = flatten_list_and_uniq(new_list)

        for ans in ancestor_list1:
            for i in ancestor(ans):
                if i.addr == LCA.addr:
                    return ans

def get_trace_from_LCA(LCA, func):
    if func.addr == LCA.addr:
        return (True, [func])

    ancestor_list1 = ancestor(func)
    if ancestor_list1 == []:
        return (False, [])

    for ans in ancestor_list1:
        if ans.addr == LCA.addr:
            return (True, [func, ans]) 

    for ans in ancestor_list1:
        res = [func]
        (ok, trace) = get_trace_from_LCA(LCA, ans) 
        if ok:
            res.extend(trace)
            return (True, res)

    # suppress error
    return (False, [])


def ancestor(func):
    result = []
    #try:
    for caller in cfg.kb.functions.callgraph.predecessors(func.addr):
        if caller in cfg.kb.functions:
            result.append(cfg.kb.functions[caller])
    #except AttributeError:
    #    print(func)
    #    exit(0)
    return result


def findnodebyaddr(myaddr):
    fixed = fix_func_addr(myaddr)
    for addr, func in cfg.kb.functions.items():
        if addr == fixed:
            return func

def fix_func_addr(addr):
    for i in range(tot_func - 1):
        if g_addr[i] <= addr < g_addr[i+1]:
            return g_addr[i]

def get_idx_from_name(name):
    txtname = name + ".txt"
    line_index = 0

    with open('ttp_one_file_per_line_new.txt', 'r') as f:
        lines = f.readlines()
        for line in lines:
            line_index += 1
            if txtname in line:
                match = re.search(r'\{.*\}', line)
                if match is None:
                    return -1, []
                dict_str = match.group(0)
                return line_index, list(ast.literal_eval(dict_str))

    return -1, []

def read_specific_line(file_path, line_number, iseval=False):
    with open(file_path, 'r') as file:
        for line in file:
            line_number -= 1
            if line_number == 0:
                if line == '\n':
                    return []
                if iseval:
                    match = re.search(r'\{.*\}', line)
                    if match is None:
                        #print("No match in read_specific_line")
                        return []
                    dict_str = match.group(0)
                    return ast.literal_eval(dict_str)
                else:
                    return line
    return []

# read line range
def read_line_range(file_path, start, end):
    with open(file_path, 'r') as file:
        lines = file.readlines()
        return lines[start-1:end]


def go_down(traces, center):
    if center >= len(traces):
        return None
    result = None
    while True:
        content = traces[center-1]
        if 'virusshare' in content:
            # return the last item seperated by space
            result = content.split()[-1]
        elif '---- log_api start ----' in content:
            # output api bounder
            break
        center -= 1
    return result

def go_up(traces, center):
    if center >= len(traces):
        return None
    while True:
        content = traces[center-1]
        if 'virusshare' in content:
            # return the last item seperated by space
            return content.split()[-1]
        elif '---- log_api ended ----' in content:
            # output api bounder
            break
        center += 1
    return None

def locate_node_by_ttp(lines, filename):
    node_lists = set()

    with open(filename, 'r') as file:
        traces = file.readlines()

    for line in lines:
        go_down_result = go_down(traces, line)
        go_up_result = go_up(traces, line)

        if go_down_result is not None:
            node_lists.add(go_down_result)
            continue
        elif go_up_result is not None:
            node_lists.add(go_up_result)
        else:
            continue
        
    return list(node_lists)

def get_evalnode_from_stacktrace(line_idx, filename):
    item = str(read_specific_line('ttp_one_file_per_line_new.txt', line_idx))

    ttps = re.search(r'\{.*\}', item)
    line_nums = re.search(r'\[.*\]', item)

    if ttps is None or line_nums is None:
        print("No ttps or line_nums")
        return

    ttp_list = ast.literal_eval(ttps.group(0))
    line_list = ast.literal_eval(line_nums.group(0))

    bottom_node = dict()
    for ttp, lines in zip(ttp_list, line_list):
        bottom_node[ttp] = locate_node_by_ttp(lines, filename)

    #print("bottom_node: ", bottom_node)

    top_node = dict()
    for ttp, nodes in bottom_node.items():
        if len(bottom_node[ttp]) == 1:
            top_node[ttp] = hex(int(bottom_node[ttp][0], 16))
        else:
            funcs = []
            for addr in nodes:
                fixed_addr = fix_func_addr(int(addr, 16))
                func = findnodebyaddr(fixed_addr)
                funcs.append(func)

            possible_combinations = []
            for i in range(len(funcs), 0, -1):
                for subset in itertools.combinations(funcs, i):
                    possible_combinations.append(subset)

            for combination in possible_combinations:
                # LCA reduce
                lca = get_multiple_LCA(list(combination))
                if lca is not None:
                    top_node[ttp] = hex(lca.addr)
                    break

            # it is impossible to reach here
            # print("all combinations failed")
                

    return top_node

def get_next_node(addr):
    for i in range(tot_func - 1):
        if g_addr[i] == addr:
            return g_addr[i+1]

    return None

def locate_main(program):
    res = []
    # initialize
    proj = angr.Project(program, load_options={'auto_load_libs': False})

    global cfg, g_func, g_addr, tot_func

    cfg = proj.analyses.CFGFast()

    g_func = []
    g_addr = []

    tot_func = 0
    for addr, func in cfg.kb.functions.items():
        # print(func.name, hex(addr))
        g_func.append(func.name), g_addr.append(addr)
        tot_func += 1

    # get the lab ttps
    basename = sys.argv[1].split('/')[-1]
    line_idx, lab_ttp_list = get_idx_from_name(basename)

    if line_idx == -1:
        #print("Not matching in map_from_line_to_file.txt")
        return None

    # -------------- STEP 1: get the address from different ttps --------------

    # get real_ttp
    real_ttp = read_specific_line('ttp_one_file_per_line_new.txt', line_idx, True)

    # get the intersection
    intersection = list(set(lab_ttp_list) & set(real_ttp))

    evalnode_dict = get_evalnode_from_stacktrace(line_idx, 'stktrace_output_new/' + basename + '.txt')

    if evalnode_dict is None or len(evalnode_dict) == 0:
        #print("No evalnode_dict")
        return None

    eval_nodes = []

    for ttp in evalnode_dict.keys():
        eval_nodes.append(findnodebyaddr(int(evalnode_dict[ttp], 16)))

    #print("evalnode_addr")
    #print(evalnode_dict)
    res.append(evalnode_dict)

    # ---------------- STEP 2: get the LCA ----------------
    lca = get_multiple_LCA(eval_nodes)

    if lca is None:
        #print("No LCA")
        return res

    #print("lca result")
    #print(hex(lca.addr))

    res.append(lca)

    # ---------------- STEP 3: get the subfunc ----------------
    subfunc_dict = dict()
    #print("subfunc result")
    for ttp, node in evalnode_dict.items():
        subfunc_dict[ttp] = get_trace_from_LCA(lca, findnodebyaddr(int(node, 16)))
        #print(ttp, get_trace_from_LCA(lca, findnodebyaddr(int(node, 16)))) 

    res.append(subfunc_dict)
    return res

if __name__ == "__main__":
    a = {'T1055':'0x412d85', 'T1057':'0x40374f', 'T1053':'0x412af0'}
    #print(a)
    result = locate_main(sys.argv[1])
    if result is None:
        print(a)
    else:
        print(result)

'''
    if len(intersection) == 0:
        print("No intersection")
        exit(0)
    if len(intersection) == 1:
        # TODO
        print("Only one intersection")
        exit(0)
    if len(intersection) == 2:
        print(intersection[0])
        print(intersection[1])


        #addrA = get_evalnode_from_stacktrace(intersection[0], line_idx)
        #exit(0)

        addrB = get_evalnode_from_stacktrace(intersection[1], line_idx)

        #addrA = fix_func_addr(int(sys.argv[2], 16))
        #addrB = fix_func_addr(int(sys.argv[3], 16))

        funcA = findnodebyaddr(addrA)
        funcB = findnodebyaddr(addrB)

        lca = get_LCA(funcA, funcB)
        if lca != None:
            print(hex(lca.addr))
            print(get_trace_from_LCA(lca, funcA))
            #pdb.set_trace()
            print(get_trace_from_LCA(lca, funcB))
        else:
            print("None")
    else:
        print("More than two intersections")
        exit(0)
'''
